/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
<<<<<<< HEAD

"use strict";

const RawSource = require("./RawSource");
const Source = require("./Source");
const { getMap, getSourceAndMap } = require("./helpers/getFromStreamChunks");
const streamChunks = require("./helpers/streamChunks");

/** @typedef {import("./CompatSource").SourceLike} SourceLike */
/** @typedef {import("./Source").Hash} Hash */
/** @typedef {import("./Source").MapOptions} MapOptions */
/** @typedef {import("./Source").RawSourceMap} RawSourceMap */
/** @typedef {import("./Source").SourceAndMap} SourceAndMap */
/** @typedef {import("./Source").SourceValue} SourceValue */
/** @typedef {import("./helpers/getGeneratedSourceInfo").GeneratedSourceInfo} GeneratedSourceInfo */
/** @typedef {import("./helpers/streamChunks").OnChunk} OnChunk */
/** @typedef {import("./helpers/streamChunks").OnName} OnName */
/** @typedef {import("./helpers/streamChunks").OnSource} OnSource */
/** @typedef {import("./helpers/streamChunks").Options} Options */

/** @typedef {string | Source | SourceLike} Child */
=======
"use strict";

const Source = require("./Source");
const RawSource = require("./RawSource");
const streamChunks = require("./helpers/streamChunks");
const { getMap, getSourceAndMap } = require("./helpers/getFromStreamChunks");
>>>>>>> f47ef2ac65efaf923d0459c5234ed08d4ca8a95b

const stringsAsRawSources = new WeakSet();

class ConcatSource extends Source {
<<<<<<< HEAD
	/**
	 *
	 * @param {Child[]} args children
	 */
	constructor(...args) {
		super();
		/**
		 * @private
		 * @type {Child[]}
		 */
		this._children = [];

		for (let i = 0; i < args.length; i++) {
			const item = args[i];
=======
	constructor() {
		super();
		this._children = [];
		for (let i = 0; i < arguments.length; i++) {
			const item = arguments[i];
>>>>>>> f47ef2ac65efaf923d0459c5234ed08d4ca8a95b
			if (item instanceof ConcatSource) {
				for (const child of item._children) {
					this._children.push(child);
				}
			} else {
				this._children.push(item);
			}
		}
<<<<<<< HEAD

		this._isOptimized = args.length === 0;
	}

	/**
	 * @returns {Source[]} children
	 */
	getChildren() {
		if (!this._isOptimized) this._optimize();
		return /** @type {Source[]} */ (this._children);
	}

	/**
	 * @param {Child} item item
	 * @returns {void}
	 */
=======
		this._isOptimized = arguments.length === 0;
	}

	getChildren() {
		if (!this._isOptimized) this._optimize();
		return this._children;
	}

>>>>>>> f47ef2ac65efaf923d0459c5234ed08d4ca8a95b
	add(item) {
		if (item instanceof ConcatSource) {
			for (const child of item._children) {
				this._children.push(child);
			}
		} else {
			this._children.push(item);
		}
		this._isOptimized = false;
	}

<<<<<<< HEAD
	/**
	 * @param {Child[]} items items
	 * @returns {void}
	 */
=======
>>>>>>> f47ef2ac65efaf923d0459c5234ed08d4ca8a95b
	addAllSkipOptimizing(items) {
		for (const item of items) {
			this._children.push(item);
		}
	}

	buffer() {
		if (!this._isOptimized) this._optimize();
<<<<<<< HEAD
		/** @type {Buffer[]} */
		const buffers = [];
		for (const child of /** @type {SourceLike[]} */ (this._children)) {
=======
		const buffers = [];
		for (const child of this._children) {
>>>>>>> f47ef2ac65efaf923d0459c5234ed08d4ca8a95b
			if (typeof child.buffer === "function") {
				buffers.push(child.buffer());
			} else {
				const bufferOrString = child.source();
				if (Buffer.isBuffer(bufferOrString)) {
					buffers.push(bufferOrString);
				} else {
					// This will not happen
					buffers.push(Buffer.from(bufferOrString, "utf-8"));
				}
			}
		}
		return Buffer.concat(buffers);
	}

<<<<<<< HEAD
	/**
	 * @returns {SourceValue} source
	 */
=======
>>>>>>> f47ef2ac65efaf923d0459c5234ed08d4ca8a95b
	source() {
		if (!this._isOptimized) this._optimize();
		let source = "";
		for (const child of this._children) {
<<<<<<< HEAD
			source += /** @type {Source} */ (child).source();
=======
			source += child.source();
>>>>>>> f47ef2ac65efaf923d0459c5234ed08d4ca8a95b
		}
		return source;
	}

	size() {
		if (!this._isOptimized) this._optimize();
		let size = 0;
		for (const child of this._children) {
<<<<<<< HEAD
			size += /** @type {Source} */ (child).size();
=======
			size += child.size();
>>>>>>> f47ef2ac65efaf923d0459c5234ed08d4ca8a95b
		}
		return size;
	}

<<<<<<< HEAD
	/**
	 * @param {MapOptions=} options map options
	 * @returns {RawSourceMap | null} map
	 */
=======
>>>>>>> f47ef2ac65efaf923d0459c5234ed08d4ca8a95b
	map(options) {
		return getMap(this, options);
	}

<<<<<<< HEAD
	/**
	 * @param {MapOptions=} options map options
	 * @returns {SourceAndMap} source and map
	 */
=======
>>>>>>> f47ef2ac65efaf923d0459c5234ed08d4ca8a95b
	sourceAndMap(options) {
		return getSourceAndMap(this, options);
	}

<<<<<<< HEAD
	/**
	 * @param {Options} options options
	 * @param {OnChunk} onChunk called for each chunk of code
	 * @param {OnSource} onSource called for each source
	 * @param {OnName} onName called for each name
	 * @returns {GeneratedSourceInfo} generated source info
	 */
	streamChunks(options, onChunk, onSource, onName) {
		if (!this._isOptimized) this._optimize();
		if (this._children.length === 1) {
			return /** @type {ConcatSource[]} */ (this._children)[0].streamChunks(
				options,
				onChunk,
				onSource,
				onName
			);
		}
=======
	streamChunks(options, onChunk, onSource, onName) {
		if (!this._isOptimized) this._optimize();
		if (this._children.length === 1)
			return this._children[0].streamChunks(options, onChunk, onSource, onName);
>>>>>>> f47ef2ac65efaf923d0459c5234ed08d4ca8a95b
		let currentLineOffset = 0;
		let currentColumnOffset = 0;
		let sourceMapping = new Map();
		let nameMapping = new Map();
		const finalSource = !!(options && options.finalSource);
		let code = "";
		let needToCloseMapping = false;
<<<<<<< HEAD
		for (const item of /** @type {Source[]} */ (this._children)) {
			/** @type {number[]} */
			const sourceIndexMapping = [];
			/** @type {number[]} */
=======
		for (const item of this._children) {
			const sourceIndexMapping = [];
>>>>>>> f47ef2ac65efaf923d0459c5234ed08d4ca8a95b
			const nameIndexMapping = [];
			let lastMappingLine = 0;
			const { generatedLine, generatedColumn, source } = streamChunks(
				item,
				options,
				// eslint-disable-next-line no-loop-func
				(
					chunk,
					generatedLine,
					generatedColumn,
					sourceIndex,
					originalLine,
					originalColumn,
					nameIndex
				) => {
					const line = generatedLine + currentLineOffset;
					const column =
						generatedLine === 1
							? generatedColumn + currentColumnOffset
							: generatedColumn;
					if (needToCloseMapping) {
						if (generatedLine !== 1 || generatedColumn !== 0) {
							onChunk(
								undefined,
								currentLineOffset + 1,
								currentColumnOffset,
								-1,
								-1,
								-1,
								-1
							);
						}
						needToCloseMapping = false;
					}
					const resultSourceIndex =
						sourceIndex < 0 || sourceIndex >= sourceIndexMapping.length
							? -1
							: sourceIndexMapping[sourceIndex];
					const resultNameIndex =
						nameIndex < 0 || nameIndex >= nameIndexMapping.length
							? -1
							: nameIndexMapping[nameIndex];
					lastMappingLine = resultSourceIndex < 0 ? 0 : generatedLine;
					if (finalSource) {
						if (chunk !== undefined) code += chunk;
						if (resultSourceIndex >= 0) {
							onChunk(
								undefined,
								line,
								column,
								resultSourceIndex,
								originalLine,
								originalColumn,
								resultNameIndex
							);
						}
					} else {
						if (resultSourceIndex < 0) {
							onChunk(chunk, line, column, -1, -1, -1, -1);
						} else {
							onChunk(
								chunk,
								line,
								column,
								resultSourceIndex,
								originalLine,
								originalColumn,
								resultNameIndex
							);
						}
					}
				},
				(i, source, sourceContent) => {
					let globalIndex = sourceMapping.get(source);
					if (globalIndex === undefined) {
						sourceMapping.set(source, (globalIndex = sourceMapping.size));
						onSource(globalIndex, source, sourceContent);
					}
					sourceIndexMapping[i] = globalIndex;
				},
				(i, name) => {
					let globalIndex = nameMapping.get(name);
					if (globalIndex === undefined) {
						nameMapping.set(name, (globalIndex = nameMapping.size));
						onName(globalIndex, name);
					}
					nameIndexMapping[i] = globalIndex;
				}
			);
			if (source !== undefined) code += source;
			if (needToCloseMapping) {
				if (generatedLine !== 1 || generatedColumn !== 0) {
					onChunk(
						undefined,
						currentLineOffset + 1,
						currentColumnOffset,
						-1,
						-1,
						-1,
						-1
					);
					needToCloseMapping = false;
				}
			}
<<<<<<< HEAD
			if (/** @type {number} */ (generatedLine) > 1) {
				currentColumnOffset = /** @type {number} */ (generatedColumn);
			} else {
				currentColumnOffset += /** @type {number} */ (generatedColumn);
=======
			if (generatedLine > 1) {
				currentColumnOffset = generatedColumn;
			} else {
				currentColumnOffset += generatedColumn;
>>>>>>> f47ef2ac65efaf923d0459c5234ed08d4ca8a95b
			}
			needToCloseMapping =
				needToCloseMapping ||
				(finalSource && lastMappingLine === generatedLine);
<<<<<<< HEAD
			currentLineOffset += /** @type {number} */ (generatedLine) - 1;
=======
			currentLineOffset += generatedLine - 1;
>>>>>>> f47ef2ac65efaf923d0459c5234ed08d4ca8a95b
		}
		return {
			generatedLine: currentLineOffset + 1,
			generatedColumn: currentColumnOffset,
			source: finalSource ? code : undefined
		};
	}

<<<<<<< HEAD
	/**
	 * @param {Hash} hash hash
	 * @returns {void}
	 */
=======
>>>>>>> f47ef2ac65efaf923d0459c5234ed08d4ca8a95b
	updateHash(hash) {
		if (!this._isOptimized) this._optimize();
		hash.update("ConcatSource");
		for (const item of this._children) {
<<<<<<< HEAD
			/** @type {Source} */
			(item).updateHash(hash);
=======
			item.updateHash(hash);
>>>>>>> f47ef2ac65efaf923d0459c5234ed08d4ca8a95b
		}
	}

	_optimize() {
		const newChildren = [];
		let currentString = undefined;
<<<<<<< HEAD
		/** @type {undefined | string | [string, string] | SourceLike} */
		let currentRawSources = undefined;
		/**
		 * @param {string} string string
		 * @returns {void}
		 */
		const addStringToRawSources = (string) => {
=======
		let currentRawSources = undefined;
		const addStringToRawSources = string => {
>>>>>>> f47ef2ac65efaf923d0459c5234ed08d4ca8a95b
			if (currentRawSources === undefined) {
				currentRawSources = string;
			} else if (Array.isArray(currentRawSources)) {
				currentRawSources.push(string);
			} else {
				currentRawSources = [
					typeof currentRawSources === "string"
						? currentRawSources
<<<<<<< HEAD
						: /** @type {string} */ (currentRawSources.source()),
=======
						: currentRawSources.source(),
>>>>>>> f47ef2ac65efaf923d0459c5234ed08d4ca8a95b
					string
				];
			}
		};
<<<<<<< HEAD
		/**
		 * @param {SourceLike} source source
		 * @returns {void}
		 */
		const addSourceToRawSources = (source) => {
			if (currentRawSources === undefined) {
				currentRawSources = source;
			} else if (Array.isArray(currentRawSources)) {
				currentRawSources.push(
					/** @type {string} */
					(source.source())
				);
=======
		const addSourceToRawSources = source => {
			if (currentRawSources === undefined) {
				currentRawSources = source;
			} else if (Array.isArray(currentRawSources)) {
				currentRawSources.push(source.source());
>>>>>>> f47ef2ac65efaf923d0459c5234ed08d4ca8a95b
			} else {
				currentRawSources = [
					typeof currentRawSources === "string"
						? currentRawSources
<<<<<<< HEAD
						: /** @type {string} */ (currentRawSources.source()),
					/** @type {string} */
					(source.source())
=======
						: currentRawSources.source(),
					source.source()
>>>>>>> f47ef2ac65efaf923d0459c5234ed08d4ca8a95b
				];
			}
		};
		const mergeRawSources = () => {
			if (Array.isArray(currentRawSources)) {
				const rawSource = new RawSource(currentRawSources.join(""));
				stringsAsRawSources.add(rawSource);
				newChildren.push(rawSource);
			} else if (typeof currentRawSources === "string") {
				const rawSource = new RawSource(currentRawSources);
				stringsAsRawSources.add(rawSource);
				newChildren.push(rawSource);
			} else {
				newChildren.push(currentRawSources);
			}
		};
		for (const child of this._children) {
			if (typeof child === "string") {
				if (currentString === undefined) {
					currentString = child;
				} else {
					currentString += child;
				}
			} else {
				if (currentString !== undefined) {
					addStringToRawSources(currentString);
					currentString = undefined;
				}
				if (stringsAsRawSources.has(child)) {
<<<<<<< HEAD
					addSourceToRawSources(
						/** @type {SourceLike} */
						(child)
					);
=======
					addSourceToRawSources(child);
>>>>>>> f47ef2ac65efaf923d0459c5234ed08d4ca8a95b
				} else {
					if (currentRawSources !== undefined) {
						mergeRawSources();
						currentRawSources = undefined;
					}
					newChildren.push(child);
				}
			}
		}
		if (currentString !== undefined) {
			addStringToRawSources(currentString);
		}
		if (currentRawSources !== undefined) {
			mergeRawSources();
		}
		this._children = newChildren;
		this._isOptimized = true;
	}
}

module.exports = ConcatSource;
