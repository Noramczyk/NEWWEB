/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

"use strict";

<<<<<<< HEAD
const Source = require("./Source");
const streamChunksOfRawSource = require("./helpers/streamChunksOfRawSource");
const {
	internString,
	isDualStringBufferCachingEnabled
} = require("./helpers/stringBufferUtils");

/** @typedef {import("./Source").Hash} Hash */
/** @typedef {import("./Source").MapOptions} MapOptions */
/** @typedef {import("./Source").RawSourceMap} RawSourceMap */
/** @typedef {import("./Source").SourceValue} SourceValue */
/** @typedef {import("./helpers/getGeneratedSourceInfo").GeneratedSourceInfo} GeneratedSourceInfo */
/** @typedef {import("./helpers/streamChunks").OnChunk} OnChunk */
/** @typedef {import("./helpers/streamChunks").OnName} OnName */
/** @typedef {import("./helpers/streamChunks").OnSource} OnSource */
/** @typedef {import("./helpers/streamChunks").Options} Options */

class RawSource extends Source {
	/**
	 * @param {string | Buffer} value value
	 * @param {boolean=} convertToString convert to string
	 */
=======
const streamChunksOfRawSource = require("./helpers/streamChunksOfRawSource");
const Source = require("./Source");

class RawSource extends Source {
>>>>>>> f47ef2ac65efaf923d0459c5234ed08d4ca8a95b
	constructor(value, convertToString = false) {
		super();
		const isBuffer = Buffer.isBuffer(value);
		if (!isBuffer && typeof value !== "string") {
<<<<<<< HEAD
			throw new TypeError("argument 'value' must be either string or Buffer");
		}
		this._valueIsBuffer = !convertToString && isBuffer;
		const internedString =
			typeof value === "string" ? internString(value) : undefined;
		/**
		 * @private
		 * @type {undefined | string | Buffer}
		 */
		this._value =
			convertToString && isBuffer
				? undefined
				: typeof value === "string"
				? internedString
				: value;
		/**
		 * @private
		 * @type {undefined | Buffer}
		 */
		this._valueAsBuffer = isBuffer ? value : undefined;
		/**
		 * @private
		 * @type {undefined | string}
		 */
		this._valueAsString = isBuffer ? undefined : internedString;
=======
			throw new TypeError("argument 'value' must be either string of Buffer");
		}
		this._valueIsBuffer = !convertToString && isBuffer;
		this._value = convertToString && isBuffer ? undefined : value;
		this._valueAsBuffer = isBuffer ? value : undefined;
		this._valueAsString = isBuffer ? undefined : value;
>>>>>>> f47ef2ac65efaf923d0459c5234ed08d4ca8a95b
	}

	isBuffer() {
		return this._valueIsBuffer;
	}

<<<<<<< HEAD
	/**
	 * @returns {SourceValue} source
	 */
	source() {
		if (this._value === undefined) {
			const value =
				/** @type {Buffer} */
				(this._valueAsBuffer).toString("utf-8");
			if (isDualStringBufferCachingEnabled()) {
				this._value = internString(value);
			}
			return value;
=======
	source() {
		if (this._value === undefined) {
			this._value = this._valueAsBuffer.toString("utf-8");
>>>>>>> f47ef2ac65efaf923d0459c5234ed08d4ca8a95b
		}
		return this._value;
	}

	buffer() {
		if (this._valueAsBuffer === undefined) {
<<<<<<< HEAD
			const value = Buffer.from(/** @type {string} */ (this._value), "utf-8");
			if (isDualStringBufferCachingEnabled()) {
				this._valueAsBuffer = value;
			}
			return value;
=======
			this._valueAsBuffer = Buffer.from(this._value, "utf-8");
>>>>>>> f47ef2ac65efaf923d0459c5234ed08d4ca8a95b
		}
		return this._valueAsBuffer;
	}

<<<<<<< HEAD
	/**
	 * @param {MapOptions=} options map options
	 * @returns {RawSourceMap | null} map
	 */
=======
>>>>>>> f47ef2ac65efaf923d0459c5234ed08d4ca8a95b
	map(options) {
		return null;
	}

	/**
<<<<<<< HEAD
	 * @param {Options} options options
	 * @param {OnChunk} onChunk called for each chunk of code
	 * @param {OnSource} onSource called for each source
	 * @param {OnName} onName called for each name
	 * @returns {GeneratedSourceInfo} generated source info
	 */
	streamChunks(options, onChunk, onSource, onName) {
		let strValue = this._valueAsString;
		if (strValue === undefined) {
			const value = this.source();
			strValue = typeof value === "string" ? value : value.toString("utf-8");
			if (isDualStringBufferCachingEnabled()) {
				this._valueAsString = internString(strValue);
			}
		}
		return streamChunksOfRawSource(
			strValue,
=======
	 * @param {object} options options
	 * @param {function(string, number, number, number, number, number, number): void} onChunk called for each chunk of code
	 * @param {function(number, string, string)} onSource called for each source
	 * @param {function(number, string)} onName called for each name
	 * @returns {void}
	 */
	streamChunks(options, onChunk, onSource, onName) {
		if (this._value === undefined) {
			this._value = Buffer.from(this._valueAsBuffer, "utf-8");
		}
		if (this._valueAsString === undefined) {
			this._valueAsString =
				typeof this._value === "string"
					? this._value
					: this._value.toString("utf-8");
		}
		return streamChunksOfRawSource(
			this._valueAsString,
>>>>>>> f47ef2ac65efaf923d0459c5234ed08d4ca8a95b
			onChunk,
			onSource,
			onName,
			!!(options && options.finalSource)
		);
	}

<<<<<<< HEAD
	/**
	 * @param {Hash} hash hash
	 * @returns {void}
	 */
	updateHash(hash) {
		hash.update("RawSource");
		hash.update(
			this._valueAsBuffer
				? /** @type {Buffer} */ (this._valueAsBuffer)
				: /** @type {string} */ (this._valueAsString)
		);
=======
	updateHash(hash) {
		if (this._valueAsBuffer === undefined) {
			this._valueAsBuffer = Buffer.from(this._value, "utf-8");
		}
		hash.update("RawSource");
		hash.update(this._valueAsBuffer);
>>>>>>> f47ef2ac65efaf923d0459c5234ed08d4ca8a95b
	}
}

module.exports = RawSource;
